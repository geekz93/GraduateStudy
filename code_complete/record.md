## MP程序原理
1. 生成原子库
    - 使用已经生成好的，在程序运行的时候将数据读入内存中
    - 在程序运行的时候生成
生成原子库需要根据离散化规则对函数进行离散化处理
2. 从原子库中选择最佳原子
    - 重原子库的第一个原子开始，求信号与原子的投影
    - 在所有原子中选出使原信号在该原子上投影最大的原子做为此次迭代的最佳原子
    - 公式表示，如此简洁~,取得的是参数γ，为一个元组,将参数带入公式就得到了原子
![](http://upload-images.jianshu.io/upload_images/3022282-cfde8fa9dc9afb6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
3. 更新重构信号及残差
    - 原信号在最佳原子上的**投影向量**作为重构信号 
    - 原信号减去重构信号得到信号残差
4. 重复步骤2，3直到满足一定条件时终止迭代
    迭代终止条件(根据具体应用设定)：
    - 硬门限法：将迭代次数上限作为迭代停止条件
    - 相关比值法：将相关比值的下限作为迭代停止条件

# 将向量单位化：向量的各分量除以向量的长度
# 单位化：当向量长度为一时，它的各个分量是多少
g=g/np.sqrt(np.sum(g*g))

# 向量的内积即为投影，即signal_r在单位向量g上的投影
# a在b上的投影的几何意义：a在b方向上射影的长度
proj=np.sum(signal_r*g)

# 投影只有长度没有方向，与单位向量相乘后才变成了一个向量
signal_reconstruct+=proj*g
